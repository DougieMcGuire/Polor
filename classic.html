<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Game - Polor (Fixed)</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@300;400;500;600;700&display=swap" rel="stylesheet">

<style>
:root{
  --primary-blue:#52C4F5; --success-green:#51CF66; --error-red:#FF6B6B;
  --answer-red:#FF6B6B; --answer-blue:#4ECDC4; --answer-yellow:#FFE66D; --answer-green:#95E1D3;
  --white:#fff; --black:#000; --gray-100:#F8F9FA; --gray-300:#DEE2E6; --gray-800:#343A40;
  --font-primary: 'Fredoka',sans-serif; --spacing-md:1rem; --spacing-lg:1.5rem; --spacing-xl:2rem;
  --radius-xl:1rem; --radius-2xl:1.5rem; --shadow-xl: 0 20px 25px -5px rgba(0,0,0,0.1), 0 10px 10px -5px rgba(0,0,0,0.04);
}
*{box-sizing:border-box;margin:0;padding:0}
body{font-family:var(--font-primary);background:linear-gradient(135deg,var(--primary-blue) 0%,#87CEEB 100%);min-height:100vh;color:var(--black)}
.host-view{display:none;padding:var(--spacing-xl);max-width:1200px;margin:0 auto;position:relative}
.host-view.active{display:block}
.game-header{background:var(--white);border-radius:var(--radius-2xl);padding:var(--spacing-lg);margin-bottom:var(--spacing-xl);text-align:center;border:4px solid var(--black);box-shadow:var(--shadow-xl);position:relative}
.question-display{font-size:2rem;font-weight:700;color:var(--gray-800);margin-bottom:var(--spacing-lg)}
.timer-display{font-size:3rem;font-weight:700;color:var(--primary-blue)}
.submission-count{position:absolute;right:16px;top:16px;font-weight:700;color:var(--gray-800);background:var(--gray-100);padding:8px 12px;border-radius:12px;border:2px solid var(--gray-300)}
.leaderboard{background:var(--white);border-radius:var(--radius-2xl);padding:var(--spacing-xl);border:4px solid var(--black);box-shadow:var(--shadow-xl)}
.leaderboard-title{font-size:1.8rem;font-weight:700;text-align:center;margin-bottom:var(--spacing-lg);color:var(--gray-800)}
.leaderboard-item{display:flex;align-items:center;gap:var(--spacing-md);padding:var(--spacing-md);background:var(--gray-100);border-radius:var(--radius-xl);margin-bottom:var(--spacing-md);border:2px solid var(--gray-300)}
.rank{font-size:1.5rem;font-weight:700;width:40px;text-align:center}
.rank.first{color:#FFD700}.rank.second{color:#C0C0C0}.rank.third{color:#CD7F32}
.player-avatar-small{width:50px;height:50px;border-radius:50%;background:var(--gray-300);border:3px solid var(--white);background-size:cover;background-position:center;display:flex;align-items:center;justify-content:center;font-weight:700;color:var(--primary-blue)}
.player-info{flex:1}
.player-name-small{font-weight:600;color:var(--gray-800)}
.player-score{font-size:1.3rem;font-weight:700;color:var(--primary-blue)}

.student-view{display:none;padding:var(--spacing-xl);max-width:800px;margin:0 auto}
.student-view.active{display:block}
.question-card{background:var(--white);border-radius:var(--radius-2xl);padding:var(--spacing-xl);margin-bottom:var(--spacing-xl);text-align:center;border:4px solid var(--black);box-shadow:var(--shadow-xl)}
.question-number{font-size:1.2rem;color:#6C757D;margin-bottom:var(--spacing-md)}
.question-text{font-size:1.8rem;font-weight:700;color:var(--gray-800);margin-bottom:var(--spacing-lg)}
.timer-student{font-size:2rem;font-weight:700;color:var(--primary-blue)}
.answers-grid{display:grid;grid-template-columns:1fr 1fr;gap:var(--spacing-lg)}
.answer-btn{padding:var(--spacing-xl);border:4px solid var(--black);border-radius:var(--radius-xl);font-size:1.3rem;font-weight:700;cursor:pointer;transition:all .3s ease;box-shadow:0 10px 15px rgba(0,0,0,0.06);min-height:100px;display:flex;align-items:center;justify-content:center;text-align:center}
.answer-btn:hover:not(:disabled){transform:translateY(-5px)}
.answer-btn:disabled{opacity:.7;cursor:not-allowed}
.answer-btn.answer-0{background:var(--answer-red);color:var(--white)}
.answer-btn.answer-1{background:var(--answer-blue);color:var(--white)}
.answer-btn.answer-2{background:var(--answer-yellow);color:var(--gray-800)}
.answer-btn.answer-3{background:var(--answer-green);color:var(--white)}
.answer-btn.selected{transform:scale(.95);opacity:.8}
.answer-btn.correct{box-shadow:0 0 0 4px rgba(46,204,113,0.12);border:4px solid #2ecc71}
.answer-btn.incorrect{box-shadow:0 0 0 4px rgba(231,76,60,0.08);border:4px solid #e74c3c}
.waiting-screen{text-align:center;padding:var(--spacing-xl);background:var(--white);border-radius:var(--radius-2xl);border:4px solid var(--black);box-shadow:var(--shadow-xl)}
.waiting-screen h2{font-size:2rem;color:var(--gray-800);margin-bottom:var(--spacing-md)}
.waiting-screen p{font-size:1.2rem;color:#6C757D}

.results-screen{display:none;text-align:center;padding:var(--spacing-xl)}
.results-screen.active{display:block}
.results-card{background:var(--white);border-radius:var(--radius-2xl);padding:var(--spacing-xl);border:4px solid var(--black);box-shadow:var(--shadow-xl)}
.final-score{font-size:3rem;font-weight:700;color:var(--primary-blue);margin:var(--spacing-lg) 0}

.next-question-btn{padding:var(--spacing-lg) var(--spacing-xl);background:var(--success-green);color:var(--white);border:4px solid var(--black);border-radius:var(--radius-xl);font-size:1.2rem;font-weight:700;cursor:pointer;box-shadow:0 10px 15px rgba(0,0,0,0.06);transition:all .3s ease}
.next-question-btn:hover{transform:translateY(-3px)}

.round-leaderboard-overlay{display:none;position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:var(--white);padding:var(--spacing-xl);border-radius:12px;border:4px solid var(--black);z-index:20;width:80%;max-width:800px;box-shadow:var(--shadow-xl)}
.round-title{font-size:1.6rem;font-weight:800;margin-bottom:var(--spacing-md);text-align:center}
.round-list{max-height:320px;overflow:auto;margin-top:12px}

.podium-screen{display:none;position:fixed;inset:0;background:rgba(0,0,0,0.6);align-items:center;justify-content:center;z-index:50}
.podium-card{background:var(--white);padding:30px;border-radius:12px;border:4px solid var(--black);width:90%;max-width:900px;text-align:center;box-shadow:var(--shadow-xl)}
.podium-list{display:flex;gap:20px;align-items:flex-end;justify-content:center;margin-top:20px}
.podium-item{width:160px;padding:10px;border-radius:8px;background:var(--gray-100);transition:all .6s ease;transform:translateY(40px);opacity:0.05;border:3px solid var(--gray-300)}
.podium-item.show{transform:translateY(0);opacity:1}
.podium-rank{font-size:1.4rem;font-weight:800}
.podium-name{font-size:1.1rem;font-weight:700;margin-top:6px}
.podium-score{font-weight:700;color:var(--primary-blue);margin-top:4px}

@media(max-width:768px){.answers-grid{grid-template-columns:1fr}.question-text{font-size:1.4rem}.answer-btn{font-size:1.1rem}.podium-list{flex-direction:column-reverse}}
</style>
</head>
<body>

<!-- Host -->
<div id="host-view" class="host-view">
  <div class="game-header">
    <div id="host-question" class="question-display">Loading question...</div>
    <div id="host-timer" class="timer-display">20</div>
    <div id="submission-count" class="submission-count">0 / 0 submitted</div>
  </div>

  <div class="leaderboard">
    <h2 class="leaderboard-title">üèÜ Leaderboard</h2>
    <div id="leaderboard-list"></div>
  </div>

  <div style="text-align:center;margin-top:var(--spacing-xl)">
    <button id="next-question-btn" class="next-question-btn" style="display:none">Next Question ‚Üí</button>
    <button id="end-game-btn" class="next-question-btn" style="display:none">üèÅ End Game</button>
  </div>

  <div id="round-leaderboard" class="round-leaderboard-overlay">
    <div class="round-title">Top players this round</div>
    <div id="round-list" class="round-list"></div>
    <div style="text-align:center;margin-top:12px"><button id="close-round-leaderboard" class="next-question-btn">Continue</button></div>
  </div>
</div>

<!-- Student -->
<div id="student-view" class="student-view">
  <div class="question-card">
    <div id="question-number" class="question-number">Question 1 of 10</div>
    <div id="question-text" class="question-text">Loading...</div>
    <div id="student-timer" class="timer-student">20</div>
  </div>

  <div id="answers-grid" class="answers-grid"></div>

  <div id="waiting-next" class="waiting-screen" style="display:none">
    <h2>‚úì Answer Submitted!</h2>
    <p>Waiting for everyone to finish...</p>
  </div>
</div>

<!-- Podium host cinematic -->
<div id="podium-screen" class="podium-screen" style="display:none;align-items:center;">
  <div class="podium-card">
    <h2 style="font-size:2rem;font-weight:900;">Final Results</h2>
    <div class="podium-list" id="podium-list">
      <div class="podium-item" id="podium-3"><div class="podium-rank">3rd</div><div class="podium-name" id="podium-3-name">‚Äî</div><div class="podium-score" id="podium-3-score">0 pts</div></div>
      <div class="podium-item" id="podium-2"><div class="podium-rank">2nd</div><div class="podium-name" id="podium-2-name">‚Äî</div><div class="podium-score" id="podium-2-score">0 pts</div></div>
      <div class="podium-item" id="podium-1"><div class="podium-rank">1st</div><div class="podium-name" id="podium-1-name">‚Äî</div><div class="podium-score" id="podium-1-score">0 pts</div></div>
    </div>
    <div style="margin-top:20px"><button id="podium-close" class="next-question-btn">Back to Dashboard</button></div>
  </div>
</div>

<!-- Personal results (player) -->
<div id="results-screen" class="results-screen">
  <div class="results-card">
    <h1>üéâ Game Over!</h1>
    <div id="final-score" class="final-score">0 points</div>
    <p id="final-rank">Great job!</p>
    <button class="next-question-btn" onclick="window.location.href='dashboard.html'" style="margin-top:var(--spacing-xl)">Back to Dashboard</button>
  </div>
</div>

<!-- Firebase compat libs -->
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>

<script>
/* CONFIG: keep your config */
const CONFIG = {
  firebase: {
    apiKey: "AIzaSyBYcuke7uz4kAQzMjUpEqbY6zvwOiY9C1k",
    authDomain: "polorapi.firebaseapp.com",
    databaseURL: "https://polorapi-default-rtdb.firebaseio.com",
    projectId: "polorapi",
    storageBucket: "polorapi.firebasestorage.app",
    messagingSenderId: "945305666819",
    appId: "1:945305666819:web:a3c535e6cb9273882a1536"
  }
};
firebase.initializeApp(CONFIG.firebase);
const auth = firebase.auth();
const database = firebase.database();

/* State */
let roomCode = null;
let roomData = null;
let isHost = false;
let playerId = null;
let currentUser = null;
let currentQuestionIndex = 0;
let timerInterval = null;
let timeRemaining = 0;
let hasAnswered = false;
let localPlayMode = false;

/* UI refs */
const hostView = document.getElementById('host-view');
const studentView = document.getElementById('student-view');
const hostQuestionEl = document.getElementById('host-question');
const hostTimerEl = document.getElementById('host-timer');
const submissionCountEl = document.getElementById('submission-count');
const nextQuestionBtn = document.getElementById('next-question-btn');
const endGameBtn = document.getElementById('end-game-btn');
const leaderboardList = document.getElementById('leaderboard-list');
const answersGrid = document.getElementById('answers-grid');
const waitingNext = document.getElementById('waiting-next');
const studentTimerEl = document.getElementById('student-timer');
const roundLbOverlay = document.getElementById('round-leaderboard');
const roundList = document.getElementById('round-list');
const closeRoundLb = document.getElementById('close-round-leaderboard');
const podiumScreen = document.getElementById('podium-screen');
const podiumClose = document.getElementById('podium-close');
const podium1Name = document.getElementById('podium-1-name');
const podium2Name = document.getElementById('podium-2-name');
const podium3Name = document.getElementById('podium-3-name');
const podium1Score = document.getElementById('podium-1-score');
const podium2Score = document.getElementById('podium-2-score');
const podium3Score = document.getElementById('podium-3-score');
const resultsScreen = document.getElementById('results-screen');
const finalScoreEl = document.getElementById('final-score');
const finalRankEl = document.getElementById('final-rank');

document.addEventListener('DOMContentLoaded', init);

async function init(){
  const urlParams = new URLSearchParams(window.location.search);
  roomCode = urlParams.get('room');
  localPlayMode = urlParams.get('play') === '1';

  if (!roomCode) { alert('No room code provided'); window.location.href='index.html'; return; }

  // Keep roomData synced
  database.ref(`rooms/${roomCode}`).on('value', snap=>{
    roomData = snap.val();
    if (!roomData) { alert('Room not found'); window.location.href='index.html'; return; }
    // keep currentQuestionIndex in sync with DB authoritative value
    currentQuestionIndex = roomData.currentQuestion || 0;
  });

  auth.onAuthStateChanged(async (user)=>{
    currentUser = user;
    // get hostId from DB
    const hostSnap = await database.ref(`rooms/${roomCode}/hostId`).once('value');
    const hostUid = hostSnap.val();

    if (user && hostUid === user.uid && !localPlayMode) {
      // this tab is host view
      isHost = true;
      playerId = 'host_' + user.uid;
      setupHostView();
    } else {
      // student path (covers non-auth too)
      await joinAsStudent();
    }

    // set up game listeners after role decided
    listenToGameState();
  });
}

/* JOIN LOGIC with duplicate-name protections */
async function joinAsStudent(){
  // try to reuse stored player id for this room
  const storedId = localStorage.getItem(`polor_player_${roomCode}`);
  const storedName = localStorage.getItem('polor_student_name');
  const playersSnap = await database.ref(`rooms/${roomCode}/players`).once('value');
  const players = playersSnap.val() || {};

  if (storedId && players[storedId]) {
    // reuse valid stored player entry
    playerId = storedId;
    // ensure name in localStorage matches DB if not set
    if (!storedName && players[storedId].name) localStorage.setItem('polor_student_name', players[storedId].name);
  } else {
    // pick / ask name; must not clash with existing players' names (case-insensitive)
    let chosenName = storedName || (currentUser ? (currentUser.displayName || `Player${Math.floor(Math.random()*900+100)}`) : `Player${Math.floor(Math.random()*900+100)}`);
    chosenName = chosenName.trim().substring(0, 40) || `Player${Math.floor(Math.random()*900+100)}`;

    // build a set of current names lowercased
    const existingNames = new Set(Object.values(players).map(p => (p.name||'').toLowerCase()));

    // loop until name unique (simple prompt fallback)
    while (existingNames.has(chosenName.toLowerCase())) {
      chosenName = prompt(`The name "${chosenName}" is already taken in this room. Please enter a different display name:`) || '';
      chosenName = chosenName.trim().substring(0,40);
      if (!chosenName) chosenName = `Player${Math.floor(Math.random()*900+100)}`;
    }

    // create player entry under rooms/{roomCode}/players
    const newRef = database.ref(`rooms/${roomCode}/players`).push();
    const newId = newRef.key;
    const newPlayer = {
      name: chosenName,
      score: 0,
      avatar: null,
      joinedAt: Date.now(),
      isHost: false
    };
    await newRef.set(newPlayer);
    playerId = newId;
    localStorage.setItem(`polor_student_name`, chosenName);
    localStorage.setItem(`polor_player_${roomCode}`, playerId);
  }

  // show student view
  setupStudentView();
}

/* UI setup */
function setupHostView(){
  hostView.classList.add('active'); studentView.classList.remove('active'); resultsScreen.classList.remove('active');
  nextQuestionBtn.addEventListener('click', hostAdvanceToNext);
  endGameBtn.addEventListener('click', hostEndGame);
  closeRoundLb.addEventListener('click', ()=>{ roundLbOverlay.style.display='none'; });
  podiumClose.addEventListener('click', ()=>{ podiumScreen.style.display='none'; window.location.href='dashboard.html'; });
  // host triggers question start (idempotent)
  hostStartQuestion();
}

function setupStudentView(){
  studentView.classList.add('active'); hostView.classList.remove('active'); resultsScreen.classList.remove('active');
}

/* LISTENERS: game's important firebase nodes */
function listenToGameState(){
  // currentQuestion authoritative changes
  database.ref(`rooms/${roomCode}/currentQuestion`).on('value', snap=>{
    const idx = snap.val() || 0;
    currentQuestionIndex = idx;
    hasAnswered = false;

    // if beyond questions -> finished
    if (roomData && currentQuestionIndex >= (roomData.questions ? roomData.questions.length : 0)) {
      if (isHost) showFinalPodium();
      else showResults();
      return;
    }

    // when question changes, host or student do respective flows
    if (isHost) hostStartQuestion();
    else displayQuestionForStudent();
  });

  // roundStatus: "active" | "review" | "finished"
  database.ref(`rooms/${roomCode}/roundStatus`).on('value', async snap=>{
    const status = snap.val();
    if (!status) return;
    if (status === 'review') {
      // host will compute scores once (if host triggers review)
      if (!isHost) {
        // students reveal answers & show correct/incorrect
        await revealAnswersToStudent();
      } else {
        // host: compute scores for this question if not computed
        await hostComputeScoresForQuestion(currentQuestionIndex);
        // show round leaderboard overlay for host
        showRoundLeaderboard();
      }
    } else if (status === 'active') {
      // students should get ready for new question
      if (!isHost) displayQuestionForStudent();
    } else if (status === 'finished') {
      if (isHost) showFinalPodium(); else showResults();
    }
  });

  // track answers submitted count for the current question
  database.ref(`rooms/${roomCode}/answers/${currentQuestionIndex}`).on('value', snap=>{
    const answers = snap.val() || {};
    const submitted = Object.keys(answers).length;
    const totalPlayers = Object.values(roomData.players || {}).filter(p => !p.isHost).length || 0;
    submissionCountEl.textContent = `${submitted} / ${totalPlayers} submitted`;

    // if host and everyone submitted -> auto set review
    if (isHost && totalPlayers>0 && submitted >= totalPlayers) {
      // set roundStatus = review (host authoritative)
      database.ref(`rooms/${roomCode}/roundStatus`).set('review');
    }
  });

  // host leaderboard live
  if (isHost) {
    database.ref(`rooms/${roomCode}/players`).on('value', snap=>{
      updateLeaderboard(snap.val() || {});
    });
  } else {
    // students listen for revealAnswers flag if needed - handled through roundStatus listener
  }
}

/* HOST: start question authoritative */
function hostStartQuestion(){
  if (!isHost || !roomData) return;
  const question = roomData.questions[currentQuestionIndex];
  if (!question) return;

  // update UI text
  hostQuestionEl.textContent = question.question;
  // set roundStatus active so students will display the question
  database.ref(`rooms/${roomCode}/roundStatus`).set('active');

  // clear previous answers for this question (fresh start)
  database.ref(`rooms/${roomCode}/answers/${currentQuestionIndex}`).remove();

  // mark question as not-yet-scored
  database.ref(`rooms/${roomCode}/scoredQuestions/${currentQuestionIndex}`).remove().catch(()=>{});

  // timer
  timeRemaining = (roomData.settings && roomData.settings.questionTimer) || 20;
  hostTimerEl.textContent = timeRemaining;
  nextQuestionBtn.style.display = 'none';
  endGameBtn.style.display = 'none';
  roundLbOverlay.style.display = 'none';

  clearInterval(timerInterval);
  timerInterval = setInterval(()=>{
    timeRemaining--;
    hostTimerEl.textContent = timeRemaining;
    if (timeRemaining <= 0) {
      clearInterval(timerInterval);
      // move to review
      database.ref(`rooms/${roomCode}/roundStatus`).set('review');
    }
  }, 1000);
}

/* STUDENT: display question */
function displayQuestionForStudent(){
  if (!roomData) return;
  const question = roomData.questions[currentQuestionIndex];
  if (!question) return;

  document.getElementById('question-number').textContent = `Question ${currentQuestionIndex + 1} of ${roomData.questions.length}`;
  document.getElementById('question-text').textContent = question.question;
  answersGrid.innerHTML = '';
  answersGrid.style.display = 'grid';
  waitingNext.style.display = 'none';
  hasAnswered = false;

  question.answers.forEach((answer, index)=>{
    const btn = document.createElement('button');
    btn.className = `answer-btn answer-${index}`;
    btn.textContent = answer;
    btn.disabled = false;
    btn.addEventListener('click', ()=> submitAnswer(index));
    answersGrid.appendChild(btn);
  });

  // start timer
  timeRemaining = (roomData.settings && roomData.settings.questionTimer) || 20;
  studentTimerEl.textContent = timeRemaining;
  clearInterval(timerInterval);
  timerInterval = setInterval(()=>{
    timeRemaining--;
    studentTimerEl.textContent = timeRemaining;
    if (timeRemaining <= 0) {
      clearInterval(timerInterval);
      if (!hasAnswered) submitAnswer(-1); // auto-submit no answer
    }
  }, 1000);
}

/* SUBMIT ANSWER (student) */
async function submitAnswer(answerIndex){
  if (hasAnswered) return;
  hasAnswered = true;
  clearInterval(timerInterval);

  // immediate feedback: disable buttons, show waiting
  const buttons = document.querySelectorAll('.answer-btn');
  buttons.forEach(btn=>btn.disabled = true);
  waitingNext.style.display = 'block';

  // Write answer to DB under answers/{questionIndex}/{playerId}
  const answerObj = {
    playerId,
    answer: answerIndex,
    timeRemaining,
    timestamp: Date.now()
  };
  await database.ref(`rooms/${roomCode}/answers/${currentQuestionIndex}/${playerId}`).set(answerObj);
  // Do not update score on submit. Score happens once in review (hostComputeScoresForQuestion).
}

/* STUDENT: reveal answers UI when roundStatus === review */
async function revealAnswersToStudent(){
  if (!roomData) return;
  const question = roomData.questions[currentQuestionIndex];
  if (!question) return;

  // Disable buttons and mark correct
  const buttons = document.querySelectorAll('.answer-btn');
  buttons.forEach((btn, idx)=>{
    btn.disabled = true;
    if (idx === question.correct) btn.classList.add('correct');
  });

  // fetch this player's answer
  const snap = await database.ref(`rooms/${roomCode}/answers/${currentQuestionIndex}/${playerId}`).once('value');
  const ans = snap.val();
  if (ans) {
    const chosen = ans.answer;
    if (chosen !== -1 && chosen !== question.correct) {
      const btn = document.querySelector(`.answer-btn.answer-${chosen}`);
      if (btn) btn.classList.add('incorrect');
    }
  } else {
    // you didn't answer - optionally mark nothing
  }

  // show result for a few seconds then show waiting for next question
  setTimeout(()=>{
    answersGrid.style.display = 'none';
    waitingNext.style.display = 'block';
  }, 900);
}

/* HOST: compute scores for the question (idempotent, sets scoredQuestions/{index} = true) */
async function hostComputeScoresForQuestion(qIndex){
  // ensure host only runs once
  const scoredSnap = await database.ref(`rooms/${roomCode}/scoredQuestions/${qIndex}`).once('value');
  if (scoredSnap.exists()) return; // already scored

  // read question, answers, players
  const question = roomData.questions[qIndex];
  const answersSnap = await database.ref(`rooms/${roomCode}/answers/${qIndex}`).once('value');
  const answers = answersSnap.val() || {};
  const playersSnap = await database.ref(`rooms/${roomCode}/players`).once('value');
  const players = playersSnap.val() || {};

  // compute new scores in memory
  const updates = {};
  for (const [pid, a] of Object.entries(answers)) {
    // ignore host-only entries accidentally present
    if (!players[pid]) continue;
    const chosen = a.answer;
    if (chosen === question.correct) {
      const questionTimer = (roomData.settings && roomData.settings.questionTimer) || 20;
      const timeBonus = Math.floor((a.timeRemaining / questionTimer) * 500);
      const points = 500 + timeBonus;
      const currentScore = (players[pid].score || 0);
      updates[`players/${pid}/score`] = currentScore + points;
    }
  }

  // apply updates atomically
  await database.ref(`rooms/${roomCode}`).update(updates);

  // mark scored
  await database.ref(`rooms/${roomCode}/scoredQuestions/${qIndex}`).set(true);
}

/* HOST: build & show round leaderboard overlay (top 10) */
async function showRoundLeaderboard(){
  if (!isHost) return;
  const playersSnap = await database.ref(`rooms/${roomCode}/players`).once('value');
  const players = playersSnap.val() || {};
  const sorted = Object.entries(players).sort((a,b)=> (b[1].score||0) - (a[1].score||0)).slice(0,10);

  roundList.innerHTML = '';
  sorted.forEach(([id,p],i)=>{
    const div = document.createElement('div');
    div.style.display='flex'; div.style.justifyContent='space-between'; div.style.padding='8px'; div.style.borderBottom='1px solid #eee';
    div.innerHTML = `<div style="font-weight:800">${i+1}. ${p.name||'Player'}</div><div style="font-weight:800">${(p.score||0)} pts</div>`;
    if (i===0) div.style.background='#fff7cc';
    if (i===1) div.style.background='#f0f4f8';
    if (i===2) div.style.background='#fcf0ea';
    roundList.appendChild(div);
  });
  roundLbOverlay.style.display = 'block';

  // show Next / End buttons visible to host (host must click to advance)
  if (currentQuestionIndex >= (roomData.questions.length - 1)) {
    endGameBtn.style.display = 'inline-block';
    nextQuestionBtn.style.display = 'none';
  } else {
    nextQuestionBtn.style.display = 'inline-block';
    endGameBtn.style.display = 'none';
  }
}

/* HOST: advance to next (host clicks Next) */
async function hostAdvanceToNext(){
  // when host advances, increment currentQuestion and set roundStatus active
  // Ensure scoring done already (should be via roundStatus 'review' handler)
  // hide overlay
  roundLbOverlay.style.display = 'none';
  // increment question index
  await database.ref(`rooms/${roomCode}/currentQuestion`).set(currentQuestionIndex + 1);
  // set roundStatus to active (students will display new question)
  await database.ref(`rooms/${roomCode}/roundStatus`).set('active');
}

/* HOST: end game */
async function hostEndGame(){
  // set roundStatus finished and status finished
  await database.ref(`rooms/${roomCode}/roundStatus`).set('finished');
  await database.ref(`rooms/${roomCode}/status`).set('finished');
  // show final podium
  showFinalPodium();
}

/* HOST: final podium cinematic */
async function showFinalPodium(){
  if (isHost) {
    const playersSnap = await database.ref(`rooms/${roomCode}/players`).once('value');
    const players = playersSnap.val() || {};
    const sorted = Object.entries(players).sort((a,b)=> (b[1].score||0) - (a[1].score||0));

    const first = sorted[0] ? sorted[0][1] : {name:'‚Äî', score:0};
    const second = sorted[1] ? sorted[1][1] : {name:'‚Äî', score:0};
    const third = sorted[2] ? sorted[2][1] : {name:'‚Äî', score:0};

    podium1Name.textContent = first.name || '‚Äî'; podium1Score.textContent = (first.score||0) + ' pts';
    podium2Name.textContent = second.name || '‚Äî'; podium2Score.textContent = (second.score||0) + ' pts';
    podium3Name.textContent = third.name || '‚Äî'; podium3Score.textContent = (third.score||0) + ' pts';

    podiumScreen.style.display = 'flex';
    const p3 = document.getElementById('podium-3'), p2 = document.getElementById('podium-2'), p1 = document.getElementById('podium-1');
    p3.classList.remove('show'); p2.classList.remove('show'); p1.classList.remove('show');
    setTimeout(()=>p3.classList.add('show'), 700);
    setTimeout(()=>p2.classList.add('show'), 1500);
    setTimeout(()=>p1.classList.add('show'), 2400);
  } else {
    showResults();
  }
}

/* PLAYER: show personal results */
async function showResults(){
  clearInterval(timerInterval);
  hostView.classList.remove('active');
  studentView.classList.remove('active');
  resultsScreen.classList.add('active');

  // get final score and rank
  const scoreSnap = await database.ref(`rooms/${roomCode}/players/${playerId}/score`).once('value');
  const finalScore = scoreSnap.val() || 0;
  finalScoreEl.textContent = finalScore + ' points';

  const playersSnap = await database.ref(`rooms/${roomCode}/players`).once('value');
  const players = playersSnap.val() || {};
  const sortedPlayers = Object.entries(players).sort((a,b)=> (b[1].score||0) - (a[1].score||0));
  const rank = sortedPlayers.findIndex(([id])=> id === playerId) + 1;
  finalRankEl.textContent = `You ranked #${rank} out of ${sortedPlayers.length} players!`;
}

/* host-side leaderboard render */
function updateLeaderboard(players){
  leaderboardList.innerHTML = '';
  const arr = Object.entries(players).sort((a,b)=> (b[1].score||0) - (a[1].score||0));
  arr.forEach(([id,player],index)=>{
    const item = document.createElement('div'); item.className='leaderboard-item';
    const rank = document.createElement('div'); rank.className='rank'; if (index===0) rank.classList.add('first'); if (index===1) rank.classList.add('second'); if (index===2) rank.classList.add('third');
    rank.textContent = index+1;
    const avatar = document.createElement('div'); avatar.className='player-avatar-small';
    if (player.avatar) avatar.style.backgroundImage = `url(${player.avatar})`; else avatar.textContent = (player.name||'?').charAt(0).toUpperCase();
    const info = document.createElement('div'); info.className='player-info'; const name = document.createElement('div'); name.className='player-name-small'; name.textContent = player.name || 'Player'; info.appendChild(name);
    const score = document.createElement('div'); score.className='player-score'; score.textContent = (player.score||0) + ' pts';
    item.appendChild(rank); item.appendChild(avatar); item.appendChild(info); item.appendChild(score);
    leaderboardList.appendChild(item);
  });

  if (isHost && roomData) {
    const q = roomData.questions[currentQuestionIndex];
    if (q) hostQuestionEl.textContent = q.question;
  }
}

/* Clean up when leaving page (optional) */
// window.addEventListener('beforeunload', async ()=>{
//   // Optionally remove player entry on disconnect (not done here by default so you can reconnect)
// });

</script>
</body>
</html>
